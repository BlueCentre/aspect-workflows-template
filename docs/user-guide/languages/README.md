# Language Support

This guide provides an overview of all supported languages and links to detailed language-specific guides.

## Supported Languages

The Aspect Workflows Template supports 8 programming languages, each with full integration into the Bazel build system, formatting, linting, and package management.

## Language Overview

| Language | Package Manager | Build Rules | Linter | Formatter |
|----------|----------------|-------------|---------|-----------|
| [JavaScript/TypeScript](#javascripttypescript) | pnpm | rules_js, rules_ts | ESLint | Prettier |
| [Python](#python) | pip | rules_python, aspect_rules_py | Ruff | Black |
| [Go](#go) | Go modules | rules_go | nogo | gofmt |
| [Java](#java) | Maven | rules_java | PMD | google-java-format |
| [Kotlin](#kotlin) | Maven | rules_kotlin | ktlint | ktlint |
| [C/C++](#cc) | system | rules_cc | clang-tidy | clang-format |
| [Rust](#rust) | Cargo | rules_rust | clippy | rustfmt |
| [Shell](#shell-bash) | - | rules_shell | shellcheck | shfmt |

## JavaScript/TypeScript

### Features
- ✅ Node.js managed by Bazel
- ✅ pnpm for package management
- ✅ TypeScript compilation
- ✅ ESLint for linting
- ✅ Prettier for formatting
- ✅ Jest for testing
- ✅ Automatic BUILD file generation

### Quick Start

```bash
# Add a package
pnpm add lodash

# Create a TypeScript file
cat > src/hello.ts << 'EOF'
export function greet(name: string): string {
    return \`Hello, \${name}!\`;
}
EOF

# Generate BUILD file (if not auto-generated)
bazel run gazelle

# Build
bazel build //src:hello
```

### Key Files
- `package.json` - Dependency declarations
- `pnpm-lock.yaml` - Locked dependency versions
- `eslint.config.mjs` - ESLint configuration
- `prettier.config.cjs` - Prettier configuration
- `tsconfig.json` - TypeScript configuration (if created)

### Dependencies

Managed via pnpm and `rules_js`:
- Dependencies translated to Bazel targets via `npm_translate_lock`
- Available as `@npm//package-name` in BUILD files

## Python

### Features
- ✅ Hermetic Python interpreter
- ✅ pip for package management
- ✅ Ruff for linting
- ✅ Black for formatting
- ✅ pytest for testing
- ✅ Gazelle for BUILD file generation
- ✅ aspect_rules_py for enhanced performance

### Quick Start

```bash
# Add a dependency to pyproject.toml
vim pyproject.toml

# Update lockfiles
./tools/repin

# Create a Python module
cat > src/hello.py << 'EOF'
def greet(name: str) -> str:
    return f"Hello, {name}!"
EOF

# Generate BUILD file
bazel run gazelle

# Build
bazel build //src:hello
```

### Key Files
- `pyproject.toml` - Project and dependency configuration
- `requirements/all.txt` - Locked dependencies
- `gazelle_python.yaml` - Gazelle configuration

### Dependencies

Managed via pip and `rules_python`:
- Dependencies declared in `pyproject.toml`
- Lockfiles generated by `./tools/repin`
- Available as `@pip//package-name` in BUILD files

## Go

### Features
- ✅ Hermetic Go SDK
- ✅ Go modules for dependencies
- ✅ nogo for static analysis
- ✅ gofmt for formatting
- ✅ Gazelle for BUILD file generation
- ✅ Testing with Go's built-in framework

### Quick Start

```bash
# Create a Go file
cat > main.go << 'EOF'
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
EOF

# Update go.mod
go mod tidy

# Update MODULE.bazel
bazel mod tidy

# Generate BUILD file
bazel run gazelle

# Build
bazel build //:main
```

### Key Files
- `go.mod` - Module definition and dependencies
- `go.sum` - Dependency checksums
- `MODULE.bazel` - Bazel module with `use_repo` declarations

### Dependencies

Managed via Go modules:
- Add imports to code
- Run `go mod tidy` to update go.mod
- Run `bazel mod tidy` to update MODULE.bazel
- Run `bazel run gazelle` to update BUILD files

## Java

### Features
- ✅ Hermetic JDK
- ✅ Maven for dependencies
- ✅ PMD for linting
- ✅ google-java-format for formatting
- ✅ JUnit for testing

### Quick Start

```bash
# Create a Java file
mkdir -p src/main/java/com/example
cat > src/main/java/com/example/Hello.java << 'EOF'
package com.example;

public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
EOF

# Create BUILD file (manually for Java)
cat > src/main/java/com/example/BUILD << 'EOF'
java_binary(
    name = "hello",
    srcs = ["Hello.java"],
    main_class = "com.example.Hello",
)
EOF

# Build
bazel build //src/main/java/com/example:hello
```

### Key Files
- `MODULE.bazel` - Maven dependencies in `maven.install`
- `maven_install.json` - Locked Maven dependencies
- `pmd.xml` - PMD configuration

### Dependencies

Managed via Maven and `rules_jvm_external`:
- Add artifacts to MODULE.bazel `maven.install` section
- Run `bazel run @unpinned_maven//:pin` to update lockfile

## Kotlin

### Features
- ✅ Kotlin compiler
- ✅ Maven for dependencies
- ✅ ktlint for linting and formatting
- ✅ JUnit for testing

### Quick Start

```bash
# Create a Kotlin file
mkdir -p src/main/kotlin/com/example
cat > src/main/kotlin/com/example/Hello.kt << 'EOF'
package com.example

fun main() {
    println("Hello, World!")
}
EOF

# Generate BUILD file
bazel run gazelle

# Build
bazel build //src/main/kotlin/com/example:hello
```

### Key Files
- `ktlint-baseline.xml` - ktlint baseline
- `.editorconfig` - Editor configuration for ktlint

### Dependencies

Same as Java - uses Maven and `rules_jvm_external`.

## C/C++

### Features
- ✅ Hermetic LLVM toolchain
- ✅ clang-tidy for linting
- ✅ clang-format for formatting
- ✅ Google Test for testing
- ✅ Compile commands generation for IDE support

### Quick Start

```bash
# Create a C++ file
cat > hello.cc << 'EOF'
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
EOF

# Generate BUILD file
bazel run gazelle

# Build
bazel build //:hello
```

### Key Files
- `.clang-tidy` - clang-tidy configuration
- `MODULE.bazel` - LLVM toolchain configuration

### Dependencies

C/C++ dependencies typically managed via:
- Bazel modules (MODULE.bazel)
- http_archive for external libraries
- System libraries (avoid for hermetic builds)

## Rust

### Features
- ✅ Hermetic Rust toolchain
- ✅ Cargo for dependency management
- ✅ clippy for linting
- ✅ rustfmt for formatting
- ✅ Built-in Rust testing

### Quick Start

```bash
# Create Rust files
mkdir -p src
cat > src/main.rs << 'EOF'
fn main() {
    println!("Hello, World!");
}
EOF

# Create BUILD file manually
cat > BUILD << 'EOF'
load("@rules_rust//rust:defs.bzl", "rust_binary")

rust_binary(
    name = "hello",
    srcs = ["src/main.rs"],
)
EOF

# Build
bazel build //:hello
```

### Key Files
- `Cargo.toml` - Rust project manifest
- `MODULE.bazel` - Rust toolchain configuration

### Dependencies

Rust dependencies can be managed via:
- `crate_universe` from rules_rust
- Manual declarations in MODULE.bazel
- Cargo for local development

## Shell (Bash)

### Features
- ✅ shellcheck for linting
- ✅ shfmt for formatting
- ✅ Executable targets

### Quick Start

```bash
# Create a shell script
cat > hello.sh << 'EOF'
#!/usr/bin/env bash
echo "Hello, World!"
EOF
chmod +x hello.sh

# Create BUILD file
cat > BUILD << 'EOF'
sh_binary(
    name = "hello",
    srcs = ["hello.sh"],
)
EOF

# Run
bazel run //:hello
```

### Key Files
- `.shellcheckrc` - shellcheck configuration

## Multi-Language Projects

You can combine multiple languages in one project:

\`\`\`mermaid
graph TB
    Project[Project Root] --> Python[Python Packages]
    Project --> Go[Go Modules]
    Project --> JS[JavaScript Packages]
    
    Python --> PyBuild[py_library, py_binary]
    Go --> GoBuild[go_library, go_binary]
    JS --> JSBuild[js_library, npm_package]
    
    PyBuild --> Integration[Integration Points]
    GoBuild --> Integration
    JSBuild --> Integration
    
    Integration --> APIs[APIs/Services]
    Integration --> CLI[CLI Tools]
    Integration --> Web[Web Applications]
\`\`\`

### Example Multi-Language Structure

```
monorepo/
├── python/
│   ├── BUILD
│   └── api/
│       ├── BUILD
│       └── server.py
├── go/
│   ├── BUILD
│   └── cmd/
│       └── cli/
│           ├── BUILD
│           └── main.go
└── web/
    ├── BUILD
    ├── package.json
    └── src/
        └── App.tsx
```

## Language Interoperability

### Python calling Go

```python
# BUILD
py_binary(
    name = "app",
    srcs = ["app.py"],
    data = ["//go/cmd:cli"],
)
```

```python
# app.py
import subprocess

result = subprocess.run(
    ["go/cmd/cli"],
    capture_output=True,
    text=True
)
print(result.stdout)
```

### JavaScript calling Python

```javascript
// BUILD
js_binary(
    name = "app",
    data = ["//python/api:server"],
)
```

```javascript
// app.js
const { spawn } = require('child_process');
const server = spawn('python/api/server');
```

## Choosing Languages

Consider these factors:

1. **Performance**: Go, Rust, C++ for high performance
2. **Ecosystem**: JavaScript for web, Python for data science
3. **Team Expertise**: Use what your team knows
4. **Domain**: Java/Kotlin for Android, Python for ML
5. **Maintenance**: Simpler languages for maintainability

## Next Steps

Choose your language and dive into detailed guides:

- [JavaScript/TypeScript Deep Dive](./languages/javascript.md)
- [Python Deep Dive](./languages/python.md)
- [Go Deep Dive](./languages/go.md)
- [Java Deep Dive](./languages/java.md)
- [Kotlin Deep Dive](./languages/kotlin.md)
- [C/C++ Deep Dive](./languages/cpp.md)
- [Rust Deep Dive](./languages/rust.md)
- [Shell Deep Dive](./languages/shell.md)

---

**Back**: [User Guide](./README.md)
